{
  "name": "autorequire",
  "version": "0.3.4",
  "description": "Automatically requires source for a module/project, provided you follow a convention.",
  "keywords": [
    "require",
    "autorequire",
    "autoload",
    "modules",
    "load",
    "loader"
  ],
  "homepage": "https://github.com/nevir/node-autorequire",
  "author": {
    "name": "Ian MacLeod",
    "email": "ian@nevir.net",
    "url": "https://github.com/nevir"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/nevir/node-autorequire/MIT-LICENSE.txt"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/nevir/node-autorequire"
  },
  "main": "./lib/autorequire",
  "directories": {
    "lib": "./lib"
  },
  "testedEngines": {
    "node": ">= 0.4.0 <= 0.4.12 || >= 0.5.0 <= 0.5.10 || >= 0.6.0 <= 0.6.19 || >= 0.7.0 <= 0.7.12 || >= 0.8.0"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "dependencies": {},
  "devDependencies": {
    "coffee-script": "1.1.3",
    "semver": "~1.0.10",
    "underscore": "~1.2.1",
    "vows": "~0.5.13"
  },
  "scripts": {
    "build-lib": "rm -rf lib && node_modules/.bin/coffee -c -o lib/ src/",
    "build-doc": "rm -rf doc && rm -rf doc && groc",
    "console": "npm run-script build-lib && rlwrap --always-readline node_modules/.bin/coffee",
    "test": "npm run-script build-lib && node_modules/.bin/vows test/*_test.coffee --isolate --spec",
    "test-all": "npm run-script build-lib && scripts/test"
  },
  "readme": "# Autorequire [![Build Status](https://secure.travis-ci.org/nevir/node-autorequire.png)](http://travis-ci.org/nevir/node-autorequire)\n\nAutorequire provides a means of defining a consistent file and directory structure for your Node.js\npackages.  It does not force any one structure upon you - instead, it provides common\nconventions, and the ability to define your own if they do not suit.\n\nAt its heart, autorequire is an extensible replacement for Node's `require()`.  It also provides a\nsimple way of navigating a node package (from within and out), using the package's directory\nstructure as a guide, and the convention to assist in naming modules.\n\nWhen interacting with an autorequired Node package, each module and directory is lazy-loaded and\nthen memoized upon reference.  This ensures that it is a minimal performance hit.\n\n\n## Usage\n\nTo use autorequire for your package, at its most basic, is just the following in your index:\n\n    module.exports = require('autorequire')('./lib');\n\nThat's it!  You no longer need to require the core Node modules in any of your project's source\nfiles, nor do they need to require each other.  Consumers of your Node.js package require it\nnormally, and should not notice a difference.\n\n\n## Defining Custom Conventions\n\nShould the default convention not suit your needs, there are [several more defined]\n(https://github.com/nevir/node-autorequire/tree/master/src/conventions).  You can specify a\nbuilt-in convention by passing its name as the second argument to autorequire:\n\n    module.exports = require('autorequire')('./lib', 'Classical');\n\nOr, should you want to override a specific piece of the convention, you can inherit from the default\nconvention.  Or, for ease, you can simply pass a hash of instance methods, and autorequire will\nmanage the inheritance for you:\n\n    module.exports = require('autorequire')('./lib', {\n      directoryToProperty: function(directoryName, parentPath) {\n        return this.underscore(directoryName);\n      }\n    });\n\nFor a full reference of the methods that a convention can define, see the docs for the default\nconvention.\n\n\n## Notes\n\n__The caveat__ to autorequire is that every autorequired module is loaded within a sandboxed\nenvironment via `vm`'s `runInNewContext`.  This is so that lazy-loaded modules do not pollute the\nglobal context for everyone.  It's also a good practice for Node.js projects to adhere to.\n",
  "readmeFilename": "README.md",
  "_id": "autorequire@0.3.4",
  "_from": "autorequire"
}
